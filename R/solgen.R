#' solgen
#'
#' Generate CNA solutions likely to exhibit submodel-relations by repeatedly
#' analysing a data set returned by a randomly generated model while using
#' different consistency and coverage thresholds in each reanalysis of the data
#'
#'
#' @param x Either an integer scalar greater than one, data frame of binary
#'   crisp set data, or a configTable object, to be passed to \code{randomDat}.
#'   Determines the number, names, and type (crisp-set, multi-value or fuzzy) of
#'   the factors in the data set used for the analyses, and consequently the
#'   type of the solutions that are generated.
#'
#' @param range Numeric vector of length two, determining the upper and lower
#'   bound of both consistency and coverage thresholds used in the reanalyses
#' @param gran Numeric scalar greater than zero and less than one, determining
#'   the granularity of variation in consistency and coverage thresholds between
#'   the reanalyses.
#' @param forceoutcome Logical; if \code{TRUE}, one of the outcomes in the DGS
#'   that returns the analyzed data is passed to CNA as the argument
#'   \code{ordering}. Might increase the probability that the returned models
#'   exhibit submodel-relations. Overriden by an explicit ordering argument
#'   given in \code{...}
#' @param verbose Logical; if \code{TRUE}, returns a data frame including all
#'   details returned by CNA
#' @param ... Additional arguments passed to \code{randomDat} and \code{cna}
#'
#' @returns A vector or data.frame of CNA solutions with extra attribute "target"
#' containing the DGS from which the data were simulated.
#'
#' @details Primary use-case is to quickly generate a throwaway set of solutions
#'   that can be used to test other functions that exploit the presence of
#'   submodel-relations in a set of solutions to asses correctness, robustness,
#'   completeness etc. First a data set is generated by \code{randomDat(x, ...)}.
#'   This data is then repeatedly analyzed with \code{cna}, using every
#'   logically possible combination of consistency and coverage thresholds
#'   determined by arguments \code{range} and \code{gran}.  Checks the arguments
#'   given in \code{...}, only valid arguments are passed further, i.e. will not
#'   break if given unused arguments. Note that if the value of \code{x} is a
#'   fuzzy set configTable, the procedure is identical to crisp set data. The
#'   only practical purpose of passing fs data is to ensure that the created
#'   solutions use the same factor names. If this is not specifically desired,
#'   it is probably quicker to assign \code{x} an integer value equal to the
#'   desired maximum number of factors in the solutions.


#' @export
solgen <- function(x = 5,
                   range = c(0.8, 0.6),
                   gran = 0.1,
                   forceoutcome = TRUE,
                   verbose = FALSE, ...){
  #x <- if(any(class(x) %in% c("data.frame", "configTable"))){x} else {full.ct(x)}
  r <- seq(min(range), max(range), by = gran)
  cc <- expand.grid(r, r)
  margs <- list(...)
  rdatargs_canuse <- c("condtype", "outcome", "compl", "how", "n.asf", "type", "cutoff", "mvlevels")
  rdargs <- margs[which(names(margs) %in% rdatargs_canuse)]
  rms <- list(x, rm.const.factors = TRUE, rm.dup.factors = TRUE)
  rdargs <- c(rms, rdargs)
  cnaargs_canuse <- names(formals(cna))[!names(formals(cna)) %in% c("x", "con.msc", "con", "cov")]
  cnaargs <- margs[which(names(margs) %in% cnaargs_canuse)]
  not_used <- margs[which(!names(margs) %in% c(rdatargs_canuse, cnaargs_canuse))]
  if(length(not_used) >= 1){warning("following arguments are ignored as not applicable: ", names(not_used))}
  dat <- do.call(randomDat, rdargs)
  if(ncol(dat) < x){while(ncol(dat) < ncol(x)){dat <- do.call(randomDat, rdargs)}}
  if (forceoutcome){
    if (!"ordering" %in% names(cnaargs)){
      target <- attributes(dat)$target
      target <- cna:::noblanks(target)
      tasfs <- unlist(cna:::extract_asf(target))
      #os <- list(ordering = list(sample(cna:::rhs(tasfs), 1)))
      os <- sample(cna:::rhs(tasfs), 1)
      os <- gsub("=.*", "", os)
      os <- list(ordering = list(os))
      #os[[1]][[1]] <- unlist(strsplit(os[[1]][[1]], ""))[[1]]
      cnaargs <- if(length(cnaargs) < 1) {os} else {c(cnaargs, os)}
    }
  }

  re <- suppressWarnings(mapply(function(a, b, ...) cna::csf(cna::cna(dat, con = a, cov = b, ...), n.init = 20),
               cc[,1], cc[,2], SIMPLIFY = FALSE, MoreArgs = if(length(cnaargs) < 1){NULL} else {cnaargs}))
  if(verbose){
    re <- do.call(rbind, re)
    } else {
    re <- do.call(rbind, re)[,2]
  }
  attr(re, "target") <- attr(dat, "target")
  return(re)


}
