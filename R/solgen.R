#' solgen
#'
#' Generate CNA solutions likely to exhibit submodel-relations by repeatedly
#' analysing a data set returned by a randomly generated model while using
#' different consistency and coverage thresholds in each reanalysis of the data.
#'
#'
#' @param x Either an integer scalar greater than one, or a data frame or
#'   configTable object of binary data, or a configTable of multi-value data.
#'
#'
#' @param range Numeric vector of length two, determining the upper and lower
#'   bound of both consistency and coverage thresholds used in the reanalyses
#' @param gran Numeric scalar between greater than zero and less than one,
#'   determining the granularity of variation in consistency and coverage
#'   thresholds between the reanalyses.
#' @param forceoutcome Logical; if \code{TRUE}, one of the outcomes in the DGS
#'   that returns the analyzed data is passed to CNA as the argument
#'   \code{ordering}. Might increase the probability that the returned models
#'   exhibit submodel-relations. Overriden by an explicit ordering argument
#'   given in \code{...}
#' @param ... Additional arguments passed to \code{randomDat} and \code{cna}
#'
#' @returns A vector of CNA solutions of class "stdComplex", "character"
#'
#' @details Primary use-case is to quickly generate a throwaway set of solutions
#'   used to test other functions that exploit the presence of
#'   submodel-relations in a set of models to asses correctness, robustness,
#'   completeness etc.First a data set is generated by \code{randomDat(x)}. This
#'   data is then repeatedly analyzed with \code{cna}, using every logically
#'   possible combination of consistency and coverage thresholds determined by
#'   arguments \code{range} and \code{gran}.  Checks the arguments given in
#'   \code{...}, only valid arguments are passed further, i.e. will not break if
#'   given unused arguments. The type of solutions generated, multi-value or
#'   not, is controlled by the first argument \code{x}: to get mv-solutions, a
#'   configTable of mv data is required, as this is what the randomConds
#'   functions used in generating the analyzed data expect.


#' @export
solgen <- function(x = 5, range = c(0.8, 0.6) , gran = 0.1, forceoutcome = TRUE, ...){
  x <- if(any(class(x) %in% c("data.frame", "configTable"))){x} else {full.ct(x)}
  r <- seq(min(range), max(range), by = gran)
  cc <- expand.grid(r, r)
  margs <- list(...)
  rdatargs_canuse <- c("condtype", "outcome", "compl", "how", "n.asf", "type", "cutoff")
  rdargs <- margs[which(names(margs) %in% rdatargs_canuse)]
  rms <- list(x, rm.const.factors = TRUE, rm.dup.factors = TRUE)
  rdargs <- c(rms, rdargs)
  cnaargs_canuse <- names(formals(cna))[!names(formals(cna)) %in% c("x", "con.msc", "con", "cov")]
  cnaargs <- margs[which(names(margs) %in% cnaargs_canuse)]
  not_used <- margs[which(!names(margs) %in% c(rdatargs_canuse, cnaargs_canuse))]
  if(length(not_used) >= 1){warning("following arguments are ignored as not applicable: ", names(not_used))}
  dat <- do.call(randomDat, rdargs)
  if(ncol(dat) < ncol(x)){while(ncol(dat) < ncol(x)){dat <- do.call(randomDat, rdargs)}}
  if (forceoutcome){
    if (!"ordering" %in% names(cnaargs)){
      target <- attributes(dat)$target
      tasfs <- unlist(cna:::extract_asf(target))
      os <- list(ordering = list(sample(cna:::rhs(tasfs), 1)))
      os[[1]][[1]] <- unlist(strsplit(os[[1]][[1]], ""))[[1]]
      cnaargs <- if(length(cnaargs) < 1) {os} else {c(cnaargs, os)}
    }
  }

  re <- suppressWarnings(mapply(function(a, b, ...) cna::csf(cna::cna(dat, con = a, cov = b, ...), n.init = 20),
               cc[,1], cc[,2], SIMPLIFY = FALSE, MoreArgs = if(length(cnaargs) < 1){NULL} else {cnaargs}))
  re <- do.call(rbind, re)[,2]
  attributes(re)$target <- attributes(dat)$target
  return(re)


}
